# Fractals


<p>
    The basic aim of this project was to develop a Wavetable synthesiser which stores a pre- computed wavetable and then reconstructs the wave when needed based on frequency and sample rate.
</p>

<p>
To allow for interesting sounds to be generated the program will generate a wavetable with 256 possible frames which can then be scanned through using a wavetable position slider, that will slightly morph the waveform at each step.
</p>

<p>
Each frame is composed of 2048 samples to allow for high-quality reconstruction of the audio signal at various frequencies.
</p>

<p>
The benefits of a generating audio from a wavetable is that it has a very low computational overhead, but it comes at the cost of a lower quality signal. In contrast, computing a waveform like a sine wave in real-time will result in a very high quality signal, but the computational overhead of running the sin function is very high which is why it is, in some cases, more useful to use a wavetable. Such an occasion is when building an additive synth, in which, dozens of individual oscillators are needed and generating the signals in real-time becomes a problem when running many instances of a single plugin. In the case of my plugin, I am running 16 voices which in turn also contain each 16 oscillators upsampled by a factor of four yielding a total oscillator count equivalent of 1024. If this were all computed in real-time the cost would be extremely high.
</p>

<p>
The greatest hurdle that arises is the aliasing problem which becomes apparent when reconstructing tones at high frequencies. This occurs because upper harmonics which are generated by imperfect signal reconstruction are limited by the Nyquist frequency limit and are thus reflected as lower harmonics that, if not dealt with, compromise the quality of the signal.
</p>

<p>
To deal with this problem I have decided to upsample the generated audio and then filter the generated upper harmonics with a chain of low-pass filters and then down sample the signal back to the original sample rate. This eliminates most of the problem and increases the quality of the reconstructed signal by a fair amount.
</p>

<p>
One issue with this method is that the higher the upsampling and the more filters used to clean up the signal, the higher the computational cost of the entire process which could defeat the purpose of using a wavetable in the first place.
</p>

<p>
The wavetables are computed at runtime when constructing each voice and then stored; each table is made up of four basic oscillator types: a sine wave, a triangle wave, a sawtooth wave and a square wave. 256 frame are then constructed by running a linear interpolation algorithm on wave pairs to create a smooth transition between each step in the wavetable. In this case the morphing goes: sine -> triangle -> sawtooth- > square.
</p>

<p>
In the process block for each voice I upsample the sample rate for all oscillators, sum all upsampled signals and finally filter all the extra harmonics with a series of low-pass filters.
</p>

<p>
Each voice contains a series of 16 oscillators which are used to thicken up the sound and add movement and richness to each generated tone. Each voice has a slight detune that creates a sense of richness. The detune amount and the oscillator voice count are both manipulatable parameters in the plugin.
</p>

<p>
Already with this setup, it is possible to create quite a variety of different sounds. By tuning the ADSR it is possible to achieve massive sounding leads, thick droning and atmospheric pads, tight sharp plucks and much more.
</p>

<p>
The synth also has a pitch bend capability allowing for the manipulation of the pitch of the oscillators while playing . This I have found, when combined with the reverb towards the end of the signal chain, can create some really interesting and unpredictable results.
</p>

<p>
One setup I found particularly inspiring is the adding together of the pitch bend and reverb with 16 heavily detuned sine oscillators which creates spooky and watery, almost ghost-like sounds.
</p>

<p>
To allow for a more natural and playable instrument I mapped the midi velocity value of each voice trigger to a gain parameter. This allows different dynamics to result in the playing of the instrument.
</p>

<p>
The final element of note in the DSP is a low-pass filter just before the reverb towards the end of the signal path. This is particularly useful for taming the harsher frequencies of the square and sawtooth waves and is also useful, when modulated, to create bass sounds and thick evolving chord pads. Subtractive synthesis principles work well in the context of filtering the harmonics generated by the wavetable and modulating the position of the wavetable.
</p>

<p>
The main issue for this particular plug-in is the low quality of the oscillators at high frequencies. As I have already mentioned, I am upsampling and filtering out the generated harmonics to remove aliasing, but there is still much to be desired in the quality. At the moment I am using 4x upsample and four low-pass filters at 20 KHz. The higher both of these values are, the higher the quality of the generated audio, but this will also dramatically increase computational cost.
</p>

<p>
One nice thing about this setup is that by creating a simple algorithm which extracts frames from an audio file will allow for any audio material to be used to create a wavetable, allowing for many more sound generation possibilities.
</p>

